// この関数はヒープメモリ上の資源の所有権を取る。
fn destroy_box(c: Box<i32>) {
    println!("Destroying a box that contains {}", c);

    // `c`は破棄されてメモリは解放される。
}

fn main() {
    // スタック上に置かれた整数
    let x = 5u32;

    // `x`を`y`にコピーする。元の値が移動するわけではない。
    let y = x;

    // 両方の値はそれぞれ独立に使うことができる。
    println!("x is {}, and y is {}", x, y);

    // `a`はヒープ上の整数へのポインタ
    let a = Box::new(5i32);

    println!("a contains: {}", a);

    // `a`を`b`にムーブする。
    let b = a;

    // すなわち、`a`の指すメモリ上の番地が`b`にコピーされるため
    // いずれもヒープ上の同じ値を指すポインタとなる。しかし所有権は`b`にある。

    // エラー！`a`は所有権を持たないため、ヒープ上のデータにアクセスできない。
    // println!("a contains: {}", a);

    // この関数はヒープ上の所有権を`b`から取る。
    destroy_box(b);

    // この時点でヒープ上の資源は解放されているので、次の操作は
    // 解放済みメモリをデリファレンスすることになる。しかしそれはコンパイラが許さない。
    // println!("b contains: {}", b);
}
